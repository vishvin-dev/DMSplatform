import React, { useState, useEffect } from 'react';
import { Button, Dropdown, DropdownToggle, DropdownMenu, DropdownItem, Spinner } from 'reactstrap';
import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import { toast } from 'react-toastify';
import { postMisReport } from "../../helpers/fakebackend_helper";

const ReportPreview = () => {
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage] = useState(10);
  const [exportLoading, setExportLoading] = useState({ excel: false, pdf: false });
  const [isLoading, setIsLoading] = useState(false);
  const [reportData, setReportData] = useState([]);

  // Extract user info from sessionStorage
  const authUser = JSON.parse(sessionStorage.getItem("authUser")) || {};
  const loginName = authUser?.user?.loginName || "Unknown User";
  const reportHeaderLocationName = authUser?.user?.reportHeaderLocationName || "Unknown Office";

  const reportInfo = {
    officeName: reportHeaderLocationName,
    generatedBy: loginName,
    generatedOn: new Date().toLocaleString()
  };

  useEffect(() => {
    const fetchReportData = async () => {
      try {
        setIsLoading(true);
        const storedPayload = localStorage.getItem("reportPayload");

        if (!storedPayload) {
          toast.error("No report parameters found");
          return;
        }

        const parsedPayload = JSON.parse(storedPayload);
        const response = await postMisReport(parsedPayload);

        if (response?.status === "success") {
          setReportData(response.data || []);
        } else {
          toast.error(response?.displayMessage || "Failed to fetch report data");
        }
      } catch (error) {
        console.error("Error fetching report:", error);
        toast.error("Error fetching report data");
      } finally {
        setIsLoading(false);
      }
    };

    fetchReportData();
  }, []);

  const handleExportExcel = () => {
    setExportLoading(prev => ({ ...prev, excel: true }));
    try {
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet([]);

      // HEADER
      XLSX.utils.sheet_add_aoa(ws, [
        ["Gulbarga Electricity Supply Company"],
        ["Location Master Report"],
        [`NameOfTheOffice : ${reportInfo.officeName}`, "", "", "", `GeneratedBy: ${reportInfo.generatedBy}`],
        [`GeneratedOn: ${reportInfo.generatedOn}`],
        []
      ], { origin: -1 });

      // Get all column headers from the first data row
      const headers = reportData.length > 0 ? Object.keys(reportData[0]) : [];
      XLSX.utils.sheet_add_aoa(ws, [headers], { origin: -1 });

      // Merging header cells
      ws["!merges"] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } }, // Title
        { s: { r: 1, c: 0 }, e: { r: 1, c: headers.length - 1 } }, // Subtitle
        { s: { r: 2, c: 0 }, e: { r: 2, c: 2 } }, // Office
        { s: { r: 2, c: 4 }, e: { r: 2, c: 4 } }, // Generated By
      ];

      // Add data rows
      reportData.forEach((row, index) => {
        const rowData = headers.map(header => row[header]);
        XLSX.utils.sheet_add_aoa(ws, [rowData], { origin: -1 });
      });

      // Column widths - adjust as needed based on your data
      const colWidths = headers.map(() => ({ wch: 20 }));
      ws["!cols"] = colWidths;

      // Apply styles
      const range = XLSX.utils.decode_range(ws["!ref"]);
      for (let r = 0; r <= range.e.r; r++) {
        for (let c = 0; c <= range.e.c; c++) {
          const addr = XLSX.utils.encode_cell({ r, c });
          ws[addr] = ws[addr] || { t: "s", v: "" };
          ws[addr].s = ws[addr].s || {};

          // Title Rows (0, 1)
          if (r === 0 || r === 1) {
            ws[addr].s = {
              font: { bold: true, sz: 14 },
              alignment: { horizontal: 'center', vertical: 'center' }
            };
          }

          // Metadata rows
          if (r === 2 || r === 3) {
            ws[addr].s = {
              font: { sz: 11 },
              alignment: { horizontal: 'left', vertical: 'center' }
            };
          }

          // Table Headers
          if (r === 5) {
            ws[addr].s = {
              font: { bold: true, color: { rgb: "FFFFFF" } },
              fill: { fgColor: { rgb: "16A085" } },
              alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
              border: {
                top: { style: "thin", color: { rgb: "000000" } },
                left: { style: "thin", color: { rgb: "000000" } },
                bottom: { style: "thin", color: { rgb: "000000" } },
                right: { style: "thin", color: { rgb: "000000" } }
              }
            };
          }
        }
      }

      XLSX.utils.book_append_sheet(wb, ws, 'Report');
      XLSX.writeFile(wb, `GESCOM_Location_Master_Report_${new Date().toISOString().slice(0, 10)}.xlsx`);
    } catch (error) {
      console.error("Excel export error:", error);
      toast.error("Failed to export to Excel");
    } finally {
      setExportLoading(prev => ({ ...prev, excel: false }));
    }
  };

const handleExportPDF = () => {
  setExportLoading(prev => ({ ...prev, pdf: true }));
  try {
    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'mm',
      format: 'a4'
    });

    // Constants for A4 landscape dimensions (297mm x 210mm)
    const pageWidth = 297;
    const pageHeight = 210;
    const margin = 10; // mm margin on all sides
    const availableWidth = pageWidth - (margin * 2);
    const startY = 30; // Start table below header

    // HEADER - Black and white
    doc.setFontSize(14);
    doc.setTextColor(0, 0, 0);
    doc.text('Gulbarga Electricity Supply Company', pageWidth / 2, 15, { align: 'center' });

    doc.setFontSize(11);
    doc.text('Location Master Report', pageWidth / 2, 22, { align: 'center' });

    doc.setFontSize(9);
    doc.text(`Office: ${reportInfo.officeName}`, margin, 28);
    doc.text(`Generated By: ${reportInfo.generatedBy}`, pageWidth / 2, 28, { align: 'center' });
    doc.text(`Generated On: ${reportInfo.generatedOn}`, pageWidth - margin, 28, { align: 'right' });

    // Get all column headers from the first data row
    const headers = reportData.length > 0 ? 
      Object.keys(reportData[0]).map(header => header) : [];

    // Prepare data for PDF
    const pdfData = reportData.map(row => 
      Object.values(row).map(value => value !== null ? value.toString() : '')
    );

    // Calculate optimal column widths
    const calculateColumnWidths = () => {
      if (reportData.length === 0) return [];

      // First calculate minimum required widths
      const minWidths = headers.map((header, colIndex) => {
        // Measure header width
        const headerWidth = doc.getStringUnitWidth(header) * 3.5; // Empirical factor
        
        // Measure content widths (sample first 10 rows for performance)
        let maxContentWidth = 0;
        const sampleSize = Math.min(10, reportData.length);
        for (let i = 0; i < sampleSize; i++) {
          const content = reportData[i][headers[colIndex]] || '';
          const contentWidth = doc.getStringUnitWidth(content.toString()) * 3.5;
          if (contentWidth > maxContentWidth) maxContentWidth = contentWidth;
        }
        
        // Return max width with some padding
        return Math.max(headerWidth, maxContentWidth) + 2;
      });

      // Calculate total required width
      const totalRequiredWidth = minWidths.reduce((sum, width) => sum + width, 0);
      
      // If fits within available width, use as-is
      if (totalRequiredWidth <= availableWidth) {
        return minWidths;
      }
      
      // Otherwise scale down proportionally
      const scaleFactor = availableWidth / totalRequiredWidth;
      return minWidths.map(width => width * scaleFactor);
    };

    const columnStyles = {};
    const colWidths = calculateColumnWidths();
    
    headers.forEach((_, index) => {
      columnStyles[index] = { 
        cellWidth: colWidths[index],
        minCellHeight: 5,
        overflow: 'linebreak'
      };
    });

    // PDF table settings
    const tableSettings = {
      head: [headers],
      body: pdfData,
      startY: startY,
      margin: { left: margin, right: margin },
      styles: {
        fontSize: 7, // Slightly smaller font to fit more content
        cellPadding: 1,
        overflow: 'linebreak',
        halign: 'left',
        textColor: [0, 0, 0],
        lineWidth: 0.1,
        lineColor: [0, 0, 0],
        valign: 'middle'
      },
      headStyles: {
        textColor: [0, 0, 0],
        fontStyle: 'bold',
        lineWidth: 0.1,
        lineColor: [0, 0, 0],
        fillColor: [255, 255, 255],
        cellPadding: 1.5
      },
      bodyStyles: {
        textColor: [0, 0, 0],
        lineWidth: 0.1,
        lineColor: [0, 0, 0],
        cellPadding: 1
      },
      alternateRowStyles: {
        fillColor: [255, 255, 255]
      },
      columnStyles: columnStyles,
      tableWidth: 'auto',
      showHead: 'everyPage',
      didDrawPage: function (data) {
        // Footer with page number
        doc.setFontSize(7);
        doc.setTextColor(100);
        doc.text(
          `Page ${data.pageNumber} of ${data.pageCount}`,
          pageWidth - margin,
          pageHeight - 5,
          { align: 'right' }
        );
      }
    };

    // Generate the table
    doc.autoTable(tableSettings);

    // Save the PDF
    doc.save(`GESCOM_Location_Master_Report_${new Date().toISOString().slice(0, 10)}.pdf`);
  } catch (error) {
    console.error("PDF export error:", error);
    toast.error("Failed to export to PDF");
  } finally {
    setExportLoading(prev => ({ ...prev, pdf: false }));
  }
};

  const indexOfLastRow = currentPage * rowsPerPage;
  const indexOfFirstRow = indexOfLastRow - rowsPerPage;
  const currentRows = reportData.slice(indexOfFirstRow, indexOfLastRow);
  const totalPages = Math.ceil(reportData.length / rowsPerPage);
  const paginate = (pageNumber) => setCurrentPage(pageNumber);

  if (isLoading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <Spinner color="primary" />
      </div>
    );
  }

  if (reportData.length === 0) {
    return (
      <div style={{ padding: '30px', textAlign: 'center' }}>
        <h3>No report data available</h3>
        <p>Please generate a report first</p>
      </div>
    );
  }

  return (
    <div className="p-4" style={{ fontFamily: 'Segoe UI', maxWidth: '100%', margin: 'auto' }}>
      <div className="text-center mb-3">
        <h2 className="mb-1 fw-bold" style={{ color: '#16a085' }}>Gulbarga Electricity Supply Company</h2>
        <h5 className="text-muted">Location Master Report</h5>
      </div>
      
      <div className="mb-3 p-3 bg-light rounded">
        <div><strong className="fs-5">NameOfTheOffice :</strong> {reportInfo.officeName}</div>
        <div><strong>GeneratedBy:</strong> {reportInfo.generatedBy}</div>
        <div><strong>GeneratedOn:</strong> {reportInfo.generatedOn}</div>
      </div>

      <div className="mb-3" style={{ overflowX: 'auto', maxWidth: '100%' }}>
        <table className="table table-bordered" style={{ fontSize: '13px', minWidth: '100%' }}>
          <thead className="text-white" style={{ backgroundColor: '#16a085' }}>
            <tr>
              {reportData.length > 0 && Object.keys(reportData[0]).map((key) => (
                <th key={key} style={{ textAlign: 'left' }}>{key}</th>
              ))}
            </tr>
          </thead>
          <tbody>
            {currentRows.map((row, index) => (
              <tr key={index} style={{ backgroundColor: index % 2 === 0 ? '#ffffff' : '#f8f9fa' }}>
                {Object.values(row).map((value, i) => (
                  <td key={i} style={{ textAlign: 'left' }}>
                    {value !== null ? value.toString() : ''}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '20px' }}>
        <button 
          onClick={() => paginate(Math.max(1, currentPage - 1))} 
          disabled={currentPage === 1}
          style={{ 
            margin: '0 5px', 
            padding: '5px 10px',
            backgroundColor: '#16a085',
            color: 'white',
            border: 'none',
            borderRadius: '4px'
          }}
        >
          Previous
        </button>

        {Array.from({ length: totalPages }, (_, i) => i + 1).map(number => (
          <button 
            key={number} 
            onClick={() => paginate(number)}
            style={{
              margin: '0 5px',
              padding: '5px 10px',
              backgroundColor: currentPage === number ? '#16a085' : 'transparent',
              color: currentPage === number ? 'white' : '#16a085',
              border: currentPage === number ? 'none' : '1px solid #16a085',
              borderRadius: '4px'
            }}
          >
            {number}
          </button>
        ))}

        <button 
          onClick={() => paginate(Math.min(totalPages, currentPage + 1))}
          disabled={currentPage === totalPages}
          style={{ 
            margin: '0 5px', 
            padding: '5px 10px',
            backgroundColor: '#16a085',
            color: 'white',
            border: 'none',
            borderRadius: '4px'
          }}
        >
          Next
        </button>
      </div>

      <div className="text-end">
        <Dropdown isOpen={dropdownOpen} toggle={() => setDropdownOpen(!dropdownOpen)}>
          <DropdownToggle color="success">Export</DropdownToggle>
          <DropdownMenu>
            <DropdownItem onClick={handleExportExcel} disabled={exportLoading.excel}>
              {exportLoading.excel ? <Spinner size="sm" /> : 'Export to Excel'}
            </DropdownItem>
            <DropdownItem onClick={handleExportPDF} disabled={exportLoading.pdf}>
              {exportLoading.pdf ? <Spinner size="sm" /> : 'Export to PDF'}
            </DropdownItem>
          </DropdownMenu>
        </Dropdown>
      </div>
    </div>
  );
};

export default ReportPreview;