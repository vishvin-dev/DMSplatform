import React, { useState, useEffect } from 'react';
import {
  Spinner,
  Dropdown,
  DropdownToggle,
  DropdownMenu,
  DropdownItem
} from 'reactstrap';
import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import { toast } from 'react-toastify';
import { postBillingReport } from "../../helpers/fakebackend_helper"

const BillingReport = () => {
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [reportData, setReportData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [exportLoading, setExportLoading] = useState({ excel: false, pdf: false });
  const [dynamicHeaders, setDynamicHeaders] = useState({
    orderByKey: '',
    orderByValueKey: '',
    subDivisionKey: '',
    subDivisionValueKey: '',
    meterReaderKey: ''
  });

  const authUser = JSON.parse(sessionStorage.getItem('authUser')) || {};
  const loginName = authUser?.user?.loginName || 'Unknown User';
  const reportHeaderLocationName = authUser?.user?.reportHeaderLocationName || 'Unknown Office';

  const reportInfo = {
    officeName: reportHeaderLocationName,
    generatedBy: loginName,
    generatedOn: new Date().toLocaleString()
  };

 useEffect(() => {
  const fetchReportData = async () => {
    try {
      setIsLoading(true);
      const storedPayload = localStorage.getItem("reportPayload");

      if (!storedPayload) {
        toast.error("No report parameters found");
        return;
      }

      const parsedPayload = JSON.parse(storedPayload);
      const response = await postBillingReport(parsedPayload);

      if (response?.status === "success" && Array.isArray(response.data)) {
        const sample = response.data[0] || {};
        const keys = Object.keys(sample);

        // Step 1: Extract string keys
        const stringKeys = keys.filter(k => typeof sample[k] === 'string');

        // Step 2: Pick first 2 string keys as dynamic group and subdivision key
        const orderByKey = stringKeys[0] || 'Unknown';
        const subDivisionKey = stringKeys[1] || stringKeys[0] || 'Unknown';

        setDynamicHeaders({
          orderByKey,
          orderByValueKey: orderByKey,
          subDivisionKey,
          subDivisionValueKey: subDivisionKey,
          meterReaderKey: subDivisionKey
        });

        const transformed = response.data.map(item => ({
          orderByName: item[orderByKey] || 'N/A',
          subDivisionName: item[subDivisionKey] || 'N/A',
          meterReaders: [{
            meterReaderName: item[subDivisionKey] || 'N/A',
            totalInstallation: parseInt(item.TotalInstallation) || 0,
            activeInstallation: parseInt(item.ActiveInstallation) || 0,
            inactiveInstallation: parseInt(item.InActiveInstallation) || 0,
            billed: parseInt(item.BilledInstallation) || 0,
            notBilled: parseInt(item.NotBilledInstallation) || 0,
            percentage: item.Percentage || '-'
          }]
        }));

        setReportData(transformed);
      } else {
        toast.error(response?.displayMessage || "Failed to fetch report data");
      }
    } catch (err) {
      console.error("Error fetching report:", err);
      toast.error("Error fetching report data");
    } finally {
      setIsLoading(false);
    }
  };

  fetchReportData();
}, []);

const handleExportExcel = () => {
    setExportLoading(prev => ({ ...prev, excel: true }));
    try {
      const wb = XLSX.utils.book_new();
      const rows = [];
      
      // 1. Header Section
      rows.push(['Gulbarga Electricity Supply Company']);
      rows.push(['Billing Efficiency Report']);
      rows.push([`Office: ${reportInfo.officeName}`]);
      rows.push([`Generated By: ${reportInfo.generatedBy}`]);
      rows.push([`Generated On: ${reportInfo.generatedOn}`]);
      rows.push([]); // Empty row
      
      // 2. Table Headers
      rows.push([
        'Sl. No.',
        dynamicHeaders.subDivisionKey, // Dynamic header
        'Installation', '', '', '', '',
        '% (Percentage)'
      ]);
      rows.push([
        '',               // Sl. No.
        '',               // SubDivision
        'Total', 'Active', 'Inactive', 'Billed', 'Not Billed',
        ''                // Percentage
      ]);
      
      // 3. Data Section
      let slNo = 1;
      let gTotal = {
        totalInstallation: 0,
        activeInstallation: 0,
        inactiveInstallation: 0,
        billed: 0,
        notBilled: 0
      };
      
      reportData.forEach((group, idx) => {
        group.meterReaders.forEach((reader, ridx) => {
          // Meter Reader Name row
          rows.push([`Meter Reader Name: ${reader.meterReaderName}`]);
          // Data row
          rows.push([
            slNo,
            group.subDivisionName,
            reader.totalInstallation,
            reader.activeInstallation,
            reader.inactiveInstallation,
            reader.billed,
            reader.notBilled,
            reader.percentage
          ]);
          // Subtotal row
          rows.push([
            '',
            'SubTotal:',
            reader.totalInstallation,
            reader.activeInstallation,
            reader.inactiveInstallation,
            reader.billed,
            reader.notBilled,
            reader.percentage
          ]);
          // Blank spacer row
          rows.push([]);
          
          // Update totals
          gTotal.totalInstallation += reader.totalInstallation;
          gTotal.activeInstallation += reader.activeInstallation;
          gTotal.inactiveInstallation += reader.inactiveInstallation;
          gTotal.billed += reader.billed;
          gTotal.notBilled += reader.notBilled;
          slNo++;
        });
      });
      
      // GrandTotal row
      rows.push([
        '',
        'GrandTotal:',
        gTotal.totalInstallation,
        gTotal.activeInstallation,
        gTotal.inactiveInstallation,
        gTotal.billed,
        gTotal.notBilled,
        ''
      ]);
      
      // Create worksheet
      const ws = XLSX.utils.aoa_to_sheet(rows);
      
      // Apply merges
      ws['!merges'] = [
        // Company Name: A1:H1
        { s: { r: 0, c: 0 }, e: { r: 0, c: 7 } },
        // Report Title: A2:H2
        { s: { r: 1, c: 0 }, e: { r: 1, c: 7 } },
        // Office: A3:H3
        { s: { r: 2, c: 0 }, e: { r: 2, c: 7 } },
        // Generated by: A4:H4
        { s: { r: 3, c: 0 }, e: { r: 3, c: 7 } },
        // Generated on: A5:H5
        { s: { r: 4, c: 0 }, e: { r: 4, c: 7 } },
        // Table "Installation" subheader: C7:G7
        { s: { r: 6, c: 2 }, e: { r: 6, c: 6 } },
        // Sl. No. header vertical: A7:A8
        { s: { r: 6, c: 0 }, e: { r: 7, c: 0 } },
        // SubDivision header vertical: B7:B8
        { s: { r: 6, c: 1 }, e: { r: 7, c: 1 } },
        // % Percentage header vertical: H7:H8
        { s: { r: 6, c: 7 }, e: { r: 7, c: 7 } },
      ];
      
      // Dynamic merges for Meter Reader Name and blank rows
      for (let idx = 8; idx < rows.length - 1; idx++) {
        if (rows[idx][0] && rows[idx][0].toString().startsWith('Meter Reader Name:')) {
          ws['!merges'].push({ s: { r: idx, c: 0 }, e: { r: idx, c: 7 } });
        }
        if (rows[idx].every(cell => cell === undefined || cell === '')) {
          ws['!merges'].push({ s: { r: idx, c: 0 }, e: { r: idx, c: 7 } });
        }
      }
      
      // Set column widths
      ws['!cols'] = [
        { wch: 10 }, // Sl. No.
        { wch: 24 }, // SubDivision
        { wch: 12 }, // Total
        { wch: 12 }, // Active
        { wch: 14 }, // Inactive
        { wch: 12 }, // Billed
        { wch: 16 }, // Not Billed
        { wch: 16 }, // Percentage
      ];
      
      // Helper function to apply styles
      function setCellStyle(r, c, style) {
        const cellAddr = XLSX.utils.encode_cell({ r, c });
        ws[cellAddr] = ws[cellAddr] || { t: "s", v: "" };
        ws[cellAddr].s = { ...ws[cellAddr].s, ...style };
      }
      
      // Apply styles
      // Company and Report Titles
      for (let r = 0; r <= 1; r++) {
        for (let c = 0; c <= 7; c++) {
          setCellStyle(r, c, {
            font: { bold: true, sz: 14 },
            alignment: { horizontal: 'center', vertical: 'center' }
          });
        }
      }
      
      // Report Info rows
      for (let r = 2; r <= 4; r++) {
        for (let c = 0; c <= 7; c++) {
          setCellStyle(r, c, {
            alignment: { horizontal: 'left', vertical: 'center' },
            font: { sz: 11 }
          });
        }
      }
      
      // Table Headers (r=6,7)
      for (let c = 0; c <= 7; c++) {
        setCellStyle(6, c, {
          font: { bold: true, color: { rgb: "FFFFFF" } },
          fill: { fgColor: { rgb: "16A085" } },
          alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
          border: {
            top: { style: "thin", color: { rgb: "000000" } },
            left: { style: "thin", color: { rgb: "000000" } },
            bottom: { style: "thin", color: { rgb: "000000" } },
            right: { style: "thin", color: { rgb: "000000" } }
          }
        });
        setCellStyle(7, c, {
          font: { bold: true, color: { rgb: "FFFFFF" } },
          fill: { fgColor: { rgb: "16A085" } },
          alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
          border: {
            top: { style: "thin", color: { rgb: "000000" } },
            left: { style: "thin", color: { rgb: "000000" } },
            bottom: { style: "thin", color: { rgb: "000000" } },
            right: { style: "thin", color: { rgb: "000000" } }
          }
        });
      }
      
      // Data rows styling
      let dataRow = 8;
      while (dataRow < rows.length) {
        // Meter Reader Name rows
        if (rows[dataRow][0] && rows[dataRow][0].toString().startsWith('Meter Reader Name:')) {
          for (let c = 0; c <= 7; c++) {
            setCellStyle(dataRow, c, {
              font: { bold: true },
              fill: { fgColor: { rgb: "EAF2F8" } },
              alignment: { horizontal: 'left', vertical: 'center' },
              border: {
                top: { style: "thin", color: { rgb: "000000" } },
                left: { style: "thin", color: { rgb: "000000" } },
                bottom: { style: "thin", color: { rgb: "000000" } },
                right: { style: "thin", color: { rgb: "000000" } }
              }
            });
          }
          dataRow++;
          continue;
        }
        
        // Subtotal row
        if (rows[dataRow][1] === 'SubTotal:') {
          for (let c = 0; c <= 7; c++) {
            setCellStyle(dataRow, c, {
              font: { bold: true },
              fill: { fgColor: { rgb: "F1F1F1" } },
              alignment: { horizontal: 'center', vertical: 'center' },
              border: {
                top: { style: "thin", color: { rgb: "000000" } },
                left: { style: "thin", color: { rgb: "000000" } },
                bottom: { style: "thin", color: { rgb: "000000" } },
                right: { style: "thin", color: { rgb: "000000" } }
              }
            });
          }
          dataRow++;
          continue;
        }
        
        // GrandTotal row
        if (rows[dataRow][1] === 'GrandTotal:') {
          for (let c = 0; c <= 7; c++) {
            setCellStyle(dataRow, c, {
              font: { bold: true, sz: 12 },
              fill: { fgColor: { rgb: "DFF0D8" } },
              alignment: { horizontal: 'center', vertical: 'center' },
              border: {
                top: { style: "thin", color: { rgb: "000000" } },
                left: { style: "thin", color: { rgb: "000000" } },
                bottom: { style: "thin", color: { rgb: "000000" } },
                right: { style: "thin", color: { rgb: "000000" } }
              }
            });
          }
          dataRow++;
          continue;
        }
        
        // Spacer row
        if (rows[dataRow].every(cell => cell === undefined || cell === '')) {
          for (let c = 0; c <= 7; c++) {
            setCellStyle(dataRow, c, {
              border: {
                top: { style: "thin", color: { rgb: "000000" } },
                left: { style: "thin", color: { rgb: "000000" } },
                bottom: { style: "thin", color: { rgb: "000000" } },
                right: { style: "thin", color: { rgb: "000000" } }
              }
            });
          }
          dataRow++;
          continue;
        }
        
        // Regular data rows
        for (let c = 0; c <= 7; c++) {
          setCellStyle(dataRow, c, {
            alignment: { horizontal: 'center', vertical: 'center' },
            border: {
              top: { style: "thin", color: { rgb: "000000" } },
              left: { style: "thin", color: { rgb: "000000" } },
              bottom: { style: "thin", color: { rgb: "000000" } },
              right: { style: "thin", color: { rgb: "000000" } }
            }
          });
        }
        dataRow++;
      }
      
      // Export the file
      XLSX.utils.book_append_sheet(wb, ws, 'Report');
      XLSX.writeFile(wb, `GESCOM_Report_${new Date().toISOString().slice(0, 10)}.xlsx`);
    } catch {
      toast.error('Excel export failed');
    } finally {
      setExportLoading(prev => ({ ...prev, excel: false }));
    }
  };

  const handleExportPDF = () => {
  setExportLoading(prev => ({ ...prev, pdf: true }));
  try {
    const doc = new jsPDF('landscape');
    const pageWidth = doc.internal.pageSize.getWidth();

    // HEADER
    doc.setFontSize(15);
    doc.setTextColor(0, 0, 0); // Black
    doc.text('Gulbarga Electricity Supply Company', pageWidth / 2, 15, { align: 'center' });

    doc.setFontSize(11);
    doc.text('Billing Efficiency Report', pageWidth / 2, 22, { align: 'center' });

    doc.setFontSize(9);
    doc.text(`Office: ${reportInfo.officeName}`, 14, 30);
    doc.text(`Generated By: ${reportInfo.generatedBy}`, pageWidth / 2, 30, { align: 'center' });
    doc.text(`Generated On: ${reportInfo.generatedOn}`, pageWidth - 14, 30, { align: 'right' });

    // Table Headers
    const head = [
      [
        { content: 'Sl. No.', rowSpan: 2, styles: { halign: 'center', valign: 'middle', textColor: [0, 0, 0] } },
        { content: dynamicHeaders.subDivisionKey, rowSpan: 2, styles: { halign: 'center', valign: 'middle', textColor: [0, 0, 0] } },
        { content: 'Installation', colSpan: 5, styles: { halign: 'center', textColor: [0, 0, 0] } },
        { content: '% (Percentage)', rowSpan: 2, styles: { halign: 'center', valign: 'middle', textColor: [0, 0, 0] } }
      ],
      [
        'Total',
        'Active',
        'Inactive',
        'Billed',
        'Not Billed'
      ]
    ];

    let slNo = 1;
    let tableBody = [];
    const totals = {
      totalInstallation: 0,
      activeInstallation: 0,
      inactiveInstallation: 0,
      billed: 0,
      notBilled: 0
    };

    reportData.forEach(group => {
      group.meterReaders.forEach(reader => {
        // Meter Reader Name
        tableBody.push(['', `Meter Reader Name: ${reader.meterReaderName}`, '', '', '', '', '', '']);
        // Data row
        tableBody.push([
          slNo++,
          group.subDivisionName,
          reader.totalInstallation,
          reader.activeInstallation,
          reader.inactiveInstallation,
          reader.billed,
          reader.notBilled,
          reader.percentage
        ]);
        // Sub Total row
        tableBody.push([
          '',
          'Sub Total:',
          reader.totalInstallation,
          reader.activeInstallation,
          reader.inactiveInstallation,
          reader.billed,
          reader.notBilled,
          reader.percentage
        ]);
        // Empty spacing row
        tableBody.push(['', '', '', '', '', '', '', '']);

        // Update totals
        totals.totalInstallation += reader.totalInstallation;
        totals.activeInstallation += reader.activeInstallation;
        totals.inactiveInstallation += reader.inactiveInstallation;
        totals.billed += reader.billed;
        totals.notBilled += reader.notBilled;
      });
    });

    // Grand Total row
    tableBody.push([
      '',
      'Grand Total:',
      totals.totalInstallation,
      totals.activeInstallation,
      totals.inactiveInstallation,
      totals.billed,
      totals.notBilled,
      '-'
    ]);

    // AutoTable
    doc.autoTable({
      head: head,
      body: tableBody,
      startY: 35,
      margin: { left: 7, right: 7 },
      styles: {
        fontSize: 8,
        cellPadding: 2,
        overflow: 'linebreak',
        halign: 'center',
        textColor: [0, 0, 0],
        lineWidth: 0.1,
        lineColor: [0, 0, 0]
      },
      headStyles: {
        fillColor: [255, 255, 255],
        textColor: [0, 0, 0],
        fontStyle: 'bold',
        lineWidth: 0.1,
        lineColor: [0, 0, 0]
      },
      alternateRowStyles: {
        fillColor: [255, 255, 255],
        textColor: [0, 0, 0]
      },
      columnStyles: {
        0: { cellWidth: 'auto', halign: 'center' },
        1: { cellWidth: 'auto', halign: 'left' },
        2: { cellWidth: 'auto' },
        3: { cellWidth: 'auto' },
        4: { cellWidth: 'auto' },
        5: { cellWidth: 'auto' },
        6: { cellWidth: 'auto' },
        7: { cellWidth: 'auto' }
      },
      didParseCell: function (data) {
        const raw = data.row.raw;

        // Meter Reader Name row
        if (raw && raw[1] && raw[1].toString().startsWith("Meter Reader Name:")) {
          data.cell.styles.fontStyle = 'bold';
          data.cell.styles.textColor = [0, 0, 0];
          data.cell.styles.halign = 'left';
        }

        // Sub Total row
        if (raw && raw[1] === 'Sub Total:') {
          data.cell.styles.fontStyle = 'bold';
          data.cell.styles.textColor = [0, 0, 0];
        }

        // Grand Total row
        if (data.row.index === tableBody.length - 1 && raw[1] === 'Grand Total:') {
          data.cell.styles.fontStyle = 'bold';
          data.cell.styles.fontSize = 10;
          data.cell.styles.textColor = [0, 0, 0];
        }
      }
    });

    doc.save(`GESCOM_Report_${new Date().toISOString().slice(0, 10)}.pdf`);
  } catch (error) {
    console.error(error);
    toast.error('PDF export failed');
  } finally {
    setExportLoading(prev => ({ ...prev, pdf: false }));
  }
};

  if (isLoading) {
    return <div className="text-center py-5"><Spinner color="primary" /></div>;
  }

return (
  <div className="p-4" style={{ fontFamily: 'Segoe UI' }}>
    <div className="text-center mb-3">
      <h2 className="mb-1 fw-bold" style={{ color: '#16a085' }}>Gulbarga Electricity Supply Company</h2>
      <h5 className="text-muted">Billing Efficiency Report</h5>
    </div>

    <div className="mb-3 p-3 bg-light rounded">
      <div><strong className="fs-5">Office:</strong> {reportInfo.officeName}</div>
      <div><strong>Generated By:</strong> {reportInfo.generatedBy}</div>
      <div><strong>Generated On:</strong> {reportInfo.generatedOn}</div>
    </div>

    <div className="table-responsive mb-3">
      <table className="table table-bordered text-center" style={{ fontSize: '13px' }}>
        <thead className="text-white" style={{ backgroundColor: '#16a085' }}>
          <tr>
            <th rowSpan="2" className="text-center align-middle">Sl. No.</th>
            <th rowSpan="2" className="text-center align-middle">{dynamicHeaders.subDivisionKey}</th>
            <th colSpan="5" className="text-center">Installation</th>
            <th rowSpan="2" className="text-center align-middle">% (Percentage)</th>
          </tr>
          <tr>
            <th>Total</th>
            <th>Active</th>
            <th>InActive</th>
            <th>Billed</th>
            <th>NotBilled</th>
          </tr>
        </thead>
        <tbody>
          {reportData.map((group, gIdx) =>
            group.meterReaders.map((reader, rIdx) => {
              const slNo = gIdx + rIdx + 1;
              return (
                <React.Fragment key={`${gIdx}-${rIdx}`}>
                  <tr style={{ backgroundColor: '#eaf2f8', fontWeight: 'bold' }}>
                    <td></td>
                    <td colSpan="7" className="text-start">
                      {dynamicHeaders.orderByKey}: {group.orderByName}
                    </td>
                  </tr>
                  <tr>
                    <td>{slNo}</td>
                    <td>{group.subDivisionName}</td>
                    <td>{reader.totalInstallation}</td>
                    <td>{reader.activeInstallation}</td>
                    <td>{reader.inactiveInstallation}</td>
                    <td>{reader.billed}</td>
                    <td>{reader.notBilled}</td>
                    <td>{reader.percentage}</td>
                  </tr>
                  <tr style={{ fontWeight: 'bold', backgroundColor: '#f1f1f1' }}>
                    <td></td>
                    <td style={{ fontSize: '16px', fontWeight: 'bold' }}>Sub Total:</td>
                    <td>{reader.totalInstallation}</td>
                    <td>{reader.activeInstallation}</td>
                    <td>{reader.inactiveInstallation}</td>
                    <td>{reader.billed}</td>
                    <td>{reader.notBilled}</td>
                    <td>{reader.percentage}</td>
                  </tr>
                  <tr><td colSpan="8" style={{ height: '10px' }}></td></tr>
                </React.Fragment>
              );
            })
          )}
          <tr style={{ backgroundColor: '#dff0d8', fontWeight: 'bold' }}>
            <td></td>
            <td style={{ fontSize: '16px', fontWeight: 'bold' }}>Grand Total:</td>
            <td>{reportData.reduce((sum, g) => sum + g.meterReaders[0].totalInstallation, 0)}</td>
            <td>{reportData.reduce((sum, g) => sum + g.meterReaders[0].activeInstallation, 0)}</td>
            <td>{reportData.reduce((sum, g) => sum + g.meterReaders[0].inactiveInstallation, 0)}</td>
            <td>{reportData.reduce((sum, g) => sum + g.meterReaders[0].billed, 0)}</td>
            <td>{reportData.reduce((sum, g) => sum + g.meterReaders[0].notBilled, 0)}</td>
            <td>-</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div className="text-end">
      <Dropdown isOpen={dropdownOpen} toggle={() => setDropdownOpen(!dropdownOpen)}>
        <DropdownToggle color="success">Export</DropdownToggle>
        <DropdownMenu>
          <DropdownItem onClick={handleExportExcel} disabled={exportLoading.excel}>
            {exportLoading.excel ? <Spinner size="sm" /> : 'Export to Excel'}
          </DropdownItem>
          <DropdownItem onClick={handleExportPDF} disabled={exportLoading.pdf}>
            {exportLoading.pdf ? <Spinner size="sm" /> : 'Export to PDF'}
          </DropdownItem>
        </DropdownMenu>
      </Dropdown>
    </div>
  </div>
);

};

export default BillingReport;